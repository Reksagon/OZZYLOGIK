Вимоги та реалізація

1. Робота з базою даних
- Використовується локальна SQLite база (stations.db).
- Читання відбувається через репозиторій, який інкапсулює всі SQL-запити та не вантажить одразу всю БД у пам’ять (RAM).

2. Відображення на карті
- Для карти використовується Google Maps API.
- На малих зумах - показуються кластерні маркери (агрегація точок у зручну кількість кластерів).
- На великих зумах - реальні точки (маркер кожної станції).
- Є кастомні вікна InfoWindow з Material-дизайном для відображення даних про точку/кластер.

3. Робота з великими обсягами даних
- Lazy loading: точки підвантажуються лише для поточного вікна карти та з обмеженням (LIMIT у SQL-запитах).
- На малих зумах (широка область) замість тисяч маркерів - малюються умовні "кластерні центри" (через агрегацію SQL GROUP BY).
- Зміна масштабу автоматично перемикає режим (кластер/точки).
- Показується Loading Indicator під час підвантаження.

4. Архітектура
Clean Architecture (MVVM + Repository pattern):
- data - робота з БД, SQL-запити, локальні джерела
- domain - business logic, use cases, сутності (Station, ClusterItem, MapResult)
- ui - ViewModel, Activity, відображення та підписка на дані
Вся бізнес-логіка винесена у UseCase (наприклад, FetchMapDataUseCase), що дозволяє легко писати тести та змінювати схему БД.

Проблеми, які вирішувались
Якщо все завантажити одразу - додаток буде некеровано використовувати пам’ять (OutOfMemory, ANR).
Головна ідея - завантажувати лише ті точки, які потрібні для відображення на поточному екрані.
На малих зумах десятки тисяч маркерів перекривають один одного, додаток "фрізить", користувачу це не дає жодної цінності.
Кластеризація: малюємо 1 маркер на кілька сотень/тисяч станцій, і лише при збільшенні масштабу показуємо справжні точки.
Повна кластеризація на боці клієнта (Google Map Utils): Не підходить із великими даними, бо всі точки все одно завантажуються у пам’ять.

Чому цей варіант найкращий?
- Швидкість і ефективність - працює з великими об’ємами даних без лагів.
- Масштабованість - легко змінювати поріг кластеризації або додати нові фічі.
- Чистота коду - легко підтримувати, зручно писати юніт-тести.

